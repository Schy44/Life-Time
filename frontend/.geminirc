{
    "rules": {
        "title": "Gemini Developer Memory: Optimized Guidelines",
        "general": {
            "code_quality": "Always provide clean, production-quality code following the stack's best practices.",
            "efficiency": "Prefer built-in functions, framework utilities, or established library methods over custom implementations for common tasks.",
            "modernity": "Use modern and efficient solutions (e.g., async/await in JS, Django best practices, React Hooks).",
            "standards": "Use meaningful variable names and follow PEP8 / ESLint standards.",
            "clarity": "Explain why a certain approach is chosen, especially when prioritizing a built-in function over a custom one.",
            "documentation": "Include short, high-value comments in code for clarity."
        },
        "stack": {
            "frontend": "React (using modern hooks and functional components)",
            "backend": "Django (leveraging the ORM, DRF, and best security practices)",
            "database": "PostgreSQL (via Supabase or Django ORM)",
            "deployment_backend": "Render",
            "deployment_frontend": "Vercel",
            "cloud_storage": "Supabase Storage"
        },
        "optimization_strategy": {
            "focus": "Performance, Readability, Maintainability.",
            "principle": "Explicitly state when a custom function is being replaced by an existing library or framework utility."
        },
        "security": {
            "rule": "Always ensure the code is secure and scalable — avoid hardcoded secrets or unsafe operations.",
            "secrets": "Never remove API keys, env variables, or secrets — only reference them securely."
        }
    }
}